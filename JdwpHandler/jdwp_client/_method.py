import struct
from ._protvars import *
from ._utils import *
from typing import List

'''
  Method modBits meaning:
    defined in Chapter 4 of The Java™ Virtual Machine Specification.
    https://docs.oracle.com/javase/specs/jvms/se10/html/jvms-4.html

  Parsed Table:

  Table 4.6-A. Method access and property flags
|---------------------------------------------------------------------------|
| Flag Name        | Value  | Interpretation                                |
|---------------------------------------------------------------------------|
| ACC_PUBLIC       | 0x0001 | Declared public; may be accessed from         |
|                  |        | outside its package.                          |
| ACC_PRIVATE      | 0x0002 | Declared private; accessible only within the  |
|                  |        | defining class.                               |
| ACC_PROTECTED    | 0x0004 | Declared protected; may be accessed within    |
|                  |        | subclasses.                                   |
| ACC_STATIC       | 0x0008 | Declared static.                              |
| ACC_FINAL        | 0x0010 | Declared final; must not be overridden        |
|                  |        | (§5.4.5).                                     |
| ACC_SYNCHRONIZED | 0x0020 | Declared synchronized; invocation is wrapped  |
|                  |        | by a monitor use.                             |
| ACC_BRIDGE       | 0x0040 | A bridge method, generated by the compiler.   |
| ACC_VARARGS      | 0x0080 | Declared with variable number of arguments.   |
| ACC_NATIVE       | 0x0100 | Declared native; implemented in a language    |
|                  |        | other than the Java programming language.     |
| ACC_ABSTRACT     | 0x0400 | Declared abstract; no implementation is       |
|                  |        | provided.                                     |
| ACC_STRICT       | 0x0800 | Declared strictfp; floating-point mode is     |
|                  |        | FP-strict.                                    |
| ACC_SYNTHETIC    | 0x1000 | Declared synthetic; not present in the        |
|                  |        | source code.                                  |
-----------------------------------------------------------------------------
'''


'''
  TODO: hold all parsed methods in a list of method classes
    create method_class type
'''

def _getClassBlockData():

  # should only left application specific classes
  block_list = [
    # unwanted java classes
    b"java.*",
    b"javax.*",
    b"sun.*",
    b"com.sun.*",

    # android specific classes
    b"dalvik.system.*",
    b"libcore.*",
    b"android.*",
    b"com.android.*",
    b"androidx.*"
  ]

  data = struct.pack(">I", len(block_list))
  mod_bytes = bytes([MODKIND_CLASS_EXCLUDE])

  # create and add entries to data
  for entry in block_list:
    data += mod_bytes + struct.pack(">I", len(entry)) + entry

  return data

# TODO: send by _events.py file
def _method_event(con, event_type: int, watchlist: List[str]):
  data  = b""
  data += bytes([event_type])
  data += bytes([SUSPEND_ALL])

  if watchlist is None:
    # use block list data
    data += _getClassBlockData()
    con.sendPacket(EVENTSET_SIG, data)
    return [con.readReplyReqId()]

  # create one event per class to watch
  data += struct.pack(">I", 1)
  data += bytes([MODKIND_CLASS_MATCH])

  req_ids = []
  for w in watchlist:
    edata = data + struct.pack(">I", len(w)) + w.bytes()

    # send event request and store requestID
    con.sendPacket(EVENTSET_SIG, edata)
    req_ids.append(con.readReplyReqId())

  # return all generated requestIDs
  return req_ids

def send_method_entry(self, use_watch: bool) -> List[int]:
  if use_watch:
    return _method_event(self.con, EVENT_METHOD_ENTRY, self.watchlist)
  else:
    return _method_event(self.con, EVENT_METHOD_ENTRY, None)

def send_method_exit_wrv(self, use_watch: bool):
  # since JDWP version 1.6.
  if use_watch:
    return _method_event(self.con, EVENT_METHOD_EXIT_WRV, self.watchlist)
  else:
    return _method_event(self.con, EVENT_METHOD_EXIT_WRV, None)


def send_method_cmd(self, cmd_code, data):
  self.socket.sendall( create_packet(self.id, cmd_code, data=data) )
  buf = read_reply(self.socket)
  if len(buf) == 0:
    return []

  # TODO: parse output
  arg_cnt = struct.unpack(">I", buf[0:4])[0]
  slots_raw = struct.unpack(">I", buf[4:8])[0]
  
  slots = []
  i = 8
  for slot in range(slots_raw):

    code_index = struct.unpack(">Q", buf[i:i+8])[0]
    name_len   = struct.unpack(">I", buf[i+8:i+12])[0]
    name       = buf[i+12:i+12+name_len]
    i += 12+name_len

    sig_len    = struct.unpack(">I", buf[i:i+4])[0]
    signature  = buf[i+4:i+4+sig_len]
    i += 4+sig_len

    sig_len    = struct.unpack(">I", buf[i:i+4])[0]
    gen_signature  = buf[i+4:i+4+sig_len]
    i += 4+sig_len

    length     = struct.unpack(">I", buf[i:i+4])[0]
    slot       = struct.unpack(">I", buf[i+4:i+8])[0]
    i += 8

    slots.append( (code_index, name, signature, gen_signature, length, slot) )

  return slots

def get_methods(self, refTypeId):
  if refTypeId not in self.methods:
    refId = self.format(self.referenceTypeIDSize, refTypeId)
    self.con.sendPacket(METHODS_SIG, refId)
    buf = self.con.readReplyBuf()
    formats = [ (self.methodIDSize, "methodId"),
                ('S', "name"),
                ('S', "signature"),
                ('I', "modBits")]
    self.methods[refTypeId] = self.parse_entries(buf, formats)

  return self.methods[refTypeId]

def get_methods_by_id(self, refTypeId, method_id):
  # retrieve all methods
  methods = self.get_methods(refTypeId)

  # return method_id from fetched class
  for meth in methods:
    if meth['methodId'] == method_id:
      return meth
  return None

def get_method_by_name(self, name):
  for refId in self.methods.keys():
    for entry in self.methods[refId]:
      if entry["name"].lower() == name.lower().bytes():
        return entry
  return None

